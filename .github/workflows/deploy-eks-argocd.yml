name: deploy-eks-argocd

on:
  push:
    branches:
      - main

# Required permissions for OIDC
permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      TF_VAR_cluster_name: devops-eks-portfolio-cluster
      TF_VAR_region: ${{ secrets.TF_BACKEND_REGION }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7
      
      - name: Print GitHub Context
        run: |
          echo "GITHUB_REPOSITORY=${{ github.repository }}"
          echo "GITHUB_REF=${{ github.ref }}"

      # Try OIDC first, fallback to access keys
      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.GITHUB_ROLE_ARN }}
          aws-region: ${{ secrets.TF_BACKEND_REGION }}
          role-session-name: github-actions-session
          role-duration-seconds: 3600
        continue-on-error: true
        id: oidc_auth

      # Fallback to access keys if OIDC fails
      - name: Configure AWS Credentials via Access Keys
        if: steps.oidc_auth.outcome == 'failure'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.TF_BACKEND_REGION }}

      # Verify AWS credentials are working
      - name: Verify AWS Credentials
        run: |
          echo "Testing AWS credentials..."
          aws sts get-caller-identity
          echo "AWS credentials are working!"

      - name: Terraform Init with S3 Backend
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_BACKEND_BUCKET }}" \
            -backend-config="key=eks/terraform.tfstate" \
            -backend-config="region=${{ secrets.TF_BACKEND_REGION }}"

      - name: Terraform Plan
        working-directory: ./terraform
        run: terraform plan -var="github_role_arn=${{ secrets.GITHUB_ROLE_ARN }}"

      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -auto-approve -var="github_role_arn=${{ secrets.GITHUB_ROLE_ARN }}"

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: v1.28.0

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --region ${{ secrets.TF_BACKEND_REGION }} --name devops-eks-portfolio-cluster

      - name: Verify kubectl connection
        run: |
          echo "Testing kubectl connection..."
          kubectl cluster-info
          kubectl get nodes

      - name: Install Argo CD
        run: |
          kubectl create namespace argocd || true
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          echo "Waiting for Argo CD server to be ready..."
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd

      - name: Expose Argo CD via LoadBalancer
        run: |
          kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

      - name: Deploy Argo CD Bootstrap App
        run: kubectl apply -f k8s/argocd/bootstrap-apps.yaml -n argocd

      - name: Wait for All ArgoCD Applications to Sync
        run: |
          sleep 30
          kubectl wait --for=condition=Available --timeout=300s deployment -l app.kubernetes.io/part-of=argocd -n argocd || true

      - name: Wait for LoadBalancer IPs
        run: |
          echo "Waiting for LoadBalancers to be assigned..."
          for svc in argocd-server grafana-app game-2048; do
            echo "Waiting for $svc..."
            timeout 300 bash -c "until kubectl get svc $svc -A -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' 2>/dev/null | grep -q .; do sleep 10; done" || echo "Timeout waiting for $svc"
          done

      - name: Display Public Endpoints
        run: |
          echo "ðŸ”¹ Argo CD: https://$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || echo 'Not ready')"
          echo "ðŸ”¹ Grafana: http://$(kubectl get svc grafana-app -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || echo 'Not ready')"
          echo "ðŸ”¹ 2048 App: http://$(kubectl get svc game-2048 -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || echo 'Not ready')"

      - name: Output Service Hostnames (Optional)
        run: |
          echo "Fetching LoadBalancer endpoints..."
          kubectl get svc -A | grep LoadBalancer || true